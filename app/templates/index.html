<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YouTube Downloader</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    :root{--muted:#9aa4b2;--accent:#ef4444;--success:#10b981}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:#071022;color:#e6eef6}
    .wrap{max-width:1100px;margin:28px auto;padding:20px}
    .panel{background:#071427;padding:18px;border-radius:12px}
    /* downloads list */
    #downloadList{position:fixed;left:18px;bottom:18px;z-index:1200;display:flex;flex-direction:column;gap:10px}
    .dl-row{background:rgba(11,18,32,0.95);padding:10px;border-radius:8px;min-width:280px}
    .dl-title{font-weight:700}
    .dl-status{color:var(--muted);margin-top:6px}
    a.dl-link{color:#7dd3fc;font-weight:700;text-decoration:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1 style="margin:0 0 8px">YouTube Downloader</h1>
      <p style="margin:0;color:var(--muted)">Use the form to inspect and queue downloads.</p>
      <!-- keep your existing server-rendered content if any -->
      {% if flashed %}
        {% for category, msg in flashed %}
          <div style="margin-top:8px;color:var(--muted)">{{ msg }}</div>
        {% endfor %}
      {% endif %}
      {% if formats %}
        <!-- existing formats UI rendered by server -->
        {{ caller() if caller is defined }}
      {% endif %}
    </div>
  </div>

  <!-- container for live download entries -->
  <div id="downloadList" aria-live="polite"></div>

  <script>
    const socket = io();

    const downloadsMap = {}; // key -> DOM element

    function createRow(key, title){
      const row = document.createElement('div');
      row.className = 'dl-row';
      row.id = `dl-${key}`;
      row.innerHTML = `
        <div class="dl-title">${title}</div>
        <div id="dl-${key}-status" class="dl-status">Queued</div>
      `;
      document.getElementById('downloadList').appendChild(row);
      downloadsMap[key] = row;
    }

    function setStatus(key, text){
      const el = document.getElementById(`dl-${key}-status`);
      if(el) el.innerHTML = text;
    }

    socket.on('connect', () => console.debug('socket connected'));
    socket.on('download_started', (data) => {
      const key = data.key;
      const title = data.title || 'download';
      if(!downloadsMap[key]) createRow(key, title);
      setStatus(key, data.message || 'Queued');
    });

    socket.on('download_status', (data) => {
      if(!data || !data.key) return;
      const msg = data.message || data.status || '...';
      if(!downloadsMap[data.key]) createRow(data.key, data.title || 'download');
      setStatus(data.key, msg);
    });

    socket.on('download_complete', (data) => {
      console.log('download_complete', data); // debug: inspect payload in browser console

      if(!data || !data.key) return;
      const key = data.key;
      if(!downloadsMap[key]){
        createRow(key, data.title || 'download');
      }

      // normalize download_url: make absolute if server sent relative path
      let downloadUrl = null;
      if (data.download_url) {
        if (data.download_url.startsWith('http://') || data.download_url.startsWith('https://')) {
          downloadUrl = data.download_url;
        } else {
          downloadUrl = window.location.origin + data.download_url;
        }
      }

      if(data.status === 'success' && downloadUrl){
        // ensure filename looks safe in the link text
        const fname = decodeURIComponent(downloadUrl.split('/').pop());
        const link = `<a class="dl-link" href="${downloadUrl}" download="${fname}">â¬‡ Download</a>`;
        setStatus(key, link);
      } else if(data.status === 'error'){
        setStatus(key, `Error: ${data.message || 'failed'}`);
      } else {
        setStatus(key, data.message || data.status || 'Done');
      }
    });

    // optional toast helper (small, unobtrusive)
    function showToast(msg, timeout=3500){
      const t = document.createElement('div');
      t.style.position='fixed'; t.style.right='18px'; t.style.top='18px';
      t.style.background='rgba(7,18,39,0.95)'; t.style.color='#e6eef6'; t.style.padding='10px';
      t.style.borderRadius='8px'; t.style.zIndex=2000; t.textContent = msg;
      document.body.appendChild(t);
      setTimeout(()=> t.remove(), timeout);
    }

    // receive generic status messages
    socket.on('download_status', d => { if(d && d.message) showToast(d.message, 2000); });
    socket.on('download_complete', d => { if(d && d.status==='success') showToast(d.message || 'Ready', 2500); else if(d && d.status==='error') showToast(d.message || 'Error', 5000); });
  </script>
</body>
</html>