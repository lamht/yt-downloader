<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>YouTube Downloader</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    :root {
      --muted: #9aa4b2;
      --accent: #ef4444;
      --success: #10b981;
      --bg: #071022;
      --panel: #071427;
      --dl-bg: rgba(11, 18, 32, 0.95);
      --toast-bg: rgba(7, 18, 39, 0.95);
      --selected-bg: rgba(239, 68, 68, 0.2);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial;
      background: var(--bg);
      color: #e6eef6;
    }

    .wrap {
      max-width: 500px;
      margin: 16px auto;
      padding: 16px;
    }

    h1 {
      font-size: 1.5rem;
      margin: 0 0 8px;
    }

    h3 {
      font-size: 1.1rem;
      margin: 0 0 8px;
      word-break: break-word;
    }

    .panel {
      background: var(--panel);
      padding: 16px;
      border-radius: 12px;
      margin-bottom: 16px;
    }

    .input-row {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .input-row input[type=text] {
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: inherit;
      font-size: 1rem;
    }

    .input-row button {
      padding: 10px;
      border-radius: 8px;
      background: var(--accent);
      border: none;
      color: #fff;
      cursor: pointer;
      font-size: 1rem;
      transition: 0.2s;
    }

    .input-row button:hover {
      opacity: 0.9;
    }

    /* ==== Formats list with scroll ==== */
    #formatsList {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
      max-height: 300px; /* scrollable height */
      overflow-y: auto;
      padding-right: 4px;
    }

    #formatsList::-webkit-scrollbar {
      width: 6px;
    }

    #formatsList::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .fmt-row {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 12px;
      border-radius: 12px;
      background: var(--dl-bg);
      border: 2px solid transparent;
      cursor: pointer;
      transition: 0.15s;
    }

    .fmt-row.selected {
      border-color: var(--accent);
      background: var(--selected-bg);
    }

    .fmt-row input {
      flex-shrink: 0;
    }

    .fmt-meta {
      flex: 1;
      font-size: 0.9rem;
      word-break: break-word;
    }

    /* Download list always visible */
    #downloadList {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 16px;
      min-height: 40px; /* always visible */
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 8px;
    }

    .dl-row {
      background: var(--dl-bg);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      word-break: break-word;
    }

    .dl-title {
      font-weight: 700;
      font-size: 0.95rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dl-status {
      color: var(--muted);
      margin-top: 4px;
      font-size: 0.85rem;
    }

    a.dl-link {
      color: #7dd3fc;
      font-weight: 700;
      text-decoration: none;
    }

    .sticky-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .sticky-actions label {
      display: flex;
      align-items: center;
      gap: 6px;
      color: var(--muted);
      cursor: pointer;
      font-size: 0.9rem;
    }

    .sticky-actions button {
      background: var(--accent);
      color: #fff;
      border-radius: 8px;
      padding: 10px 14px;
      border: none;
      cursor: pointer;
      transition: 0.2s;
      font-size: 0.95rem;
    }

    .sticky-actions button:hover {
      opacity: 0.9;
    }

    .toast {
      position: fixed;
      right: 12px;
      top: 12px;
      background: var(--toast-bg);
      color: #e6eef6;
      padding: 10px 14px;
      border-radius: 8px;
      z-index: 2000;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
      opacity: 0.95;
      transition: 0.3s;
      font-size: 0.9rem;
    }

    @media(min-width:600px) {
      .wrap {
        max-width: 600px;
      }
      h1 {
        font-size: 1.75rem;
      }
      .input-row {
        flex-direction: row;
      }
      .input-row input {
        flex: 1;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <h1>YouTube Downloader</h1>
      <form id="inspectForm" method="POST">
        <input type="hidden" name="action" value="inspect" />
        <div class="input-row">
          <input type="text" name="url" placeholder="Paste YouTube URL" required />
          <button type="submit">Inspect</button>
        </div>
      </form>

      <!-- formatsPanel luôn hiển thị -->
      <div id="formatsPanel" class="panel">
        <h3 id="videoTitle">Paste URL để xem formats</h3>
        <div id="formatsList"></div>

        <div class="sticky-actions">
          <label>
            <input type="checkbox" id="audioOnly" /> MP3 only
          </label>
          <button id="downloadBtn">⬇ Download Selected</button>
        </div>

        <!-- download list luôn hiện -->
        <div id="downloadList" aria-live="polite">
          <!-- trống lúc đầu, hiển thị download queue -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // ==== Script giữ nguyên logic ====
    let socket = null;
    const downloadsMap = {};
    const myDownloadKeys = new Set();
    let currentUrl = null;
    let selectedFormat = null;
    let idleTimeout = null;

    function showToast(msg, err = false) {
      if (!msg) return;
      const t = document.createElement('div');
      t.className = 'toast';
      t.textContent = msg;
      if (err) t.style.background = '#8b1c1c';
      document.body.appendChild(t);
      setTimeout(() => t.remove(), 3500);
    }

    function createRow(key, title) {
      if (downloadsMap[key]) return;
      const row = document.createElement('div');
      row.className = 'dl-row';
      row.id = `dl-${key}`;
      row.innerHTML =
        `<div class="dl-title">${title || 'download'}</div>` +
        `<div id="dl-${key}-status" class="dl-status">Queued</div>`;
      document.getElementById('downloadList').appendChild(row);
      downloadsMap[key] = row;
    }

    function setStatus(key, html) {
      const el = document.getElementById(`dl-${key}-status`);
      if (el) el.innerHTML = html;
    }

    function resetIdleTimer() {
      if (idleTimeout) clearTimeout(idleTimeout);
      idleTimeout = setTimeout(() => {
        if (socket) {
          socket.disconnect();
          socket = null;
          showToast('Disconnected due to inactivity', true);
        }
      }, 300000);
    }

    function initSocket() {
      if (socket) return;
      socket = io({ timeout: 5000, reconnectionAttempts: 3 });
      ['mousemove', 'keydown', 'touchstart', 'scroll'].forEach(evt => window.addEventListener(evt, resetIdleTimer, true));
      socket.on('connect', () => resetIdleTimer());
      socket.on('connect_error', () => showToast('Socket connection failed', true));
      socket.on('disconnect', () => showToast('Socket disconnected', true));
      socket.on('download_started', data => {
        if (!data || !data.key) return;
        myDownloadKeys.add(data.key);
        createRow(data.key, data.title);
        setStatus(data.key, data.message || 'Queued');
      });
      socket.on('download_status', data => {
        if (!data || !myDownloadKeys.has(data.key)) return;
        setStatus(data.key, data.message || data.status || '...');
      });
      socket.on('download_complete', data => {
        if (!data || !myDownloadKeys.has(data.key)) return;
        if (!downloadsMap[data.key]) createRow(data.key, data.title);
        if (data.status === 'done' && data.download_url) {
          const url = data.download_url;
          const fname = decodeURIComponent(url.split('/').pop());
          setStatus(data.key, `<a class="dl-link" href="${url}" download="${fname}">⬇ Download</a>`);
          showToast(data.message || 'Ready');
        } else {
          setStatus(data.key, `Error: ${data.message || 'failed'}`);
          showToast(data.message || 'Download failed', true);
        }
        myDownloadKeys.delete(data.key);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      const inspectForm = document.getElementById('inspectForm');
      const downloadBtn = document.getElementById('downloadBtn');
      const formatsList = document.getElementById('formatsList');
      const audioOnly = document.getElementById('audioOnly');

      inspectForm.addEventListener('submit', async e => {
        e.preventDefault();
        const url = inspectForm.url.value.trim();
        if (!url) return showToast('URL required', true);
        try {
          const res = await fetch('/inspect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url })
          });
          if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || 'Inspect failed');
          }
          const data = await res.json();
          currentUrl = url;
          selectedFormat = null;
          formatsList.innerHTML = '';
          if (data.title) document.getElementById('videoTitle').textContent = data.title;
          if (data.formats && data.formats.length > 0) {
            data.formats.forEach(f => {
              const row = document.createElement('label');
              row.className = 'fmt-row';
              row.innerHTML = `
                <div style="width:36px"><input type="radio" name="format_id" value="${f.format_id}"></div>
                <div class="fmt-meta">
                  <div style="font-weight:700">${f.format_id} <span class="muted">${f.format_note || ''}</span></div>
                  <div class="muted">${(f.vcodec || 'none')!=="none"?f.vcodec:'audio'} / ${(f.acodec || 'none')!=="none"?f.acodec:'no audio'}</div>
                </div>
              `;
              const inputEl = row.querySelector('input');
              inputEl.addEventListener('change', () => {
                selectedFormat = f.format_id;
                formatsList.querySelectorAll('.fmt-row').forEach(r => r.classList.remove('selected'));
                row.classList.add('selected');
              });
              formatsList.appendChild(row);
            });
          }
        } catch (err) {
          console.error(err);
          showToast(err.message, true);
        }
      });

      downloadBtn.addEventListener('click', async e => {
        if (!currentUrl) return showToast('Paste URL first', true);
        if (!selectedFormat) return showToast('Select format', true);
        initSocket();
        downloadBtn.disabled = true;
        try {
          const res = await fetch('/download', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              url: currentUrl,
              format_id: selectedFormat,
              audio_only: audioOnly.checked ? 1 : 0
            })
          });
          if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || 'Queue failed');
          }
          const data = await res.json();
          if (data.key) myDownloadKeys.add(data.key);
          showToast('Download queued');
        } catch (err) {
          console.error(err);
          showToast(err.message, true);
        } finally {
          downloadBtn.disabled = false;
        }
      });
    });
  </script>
</body>

</html>